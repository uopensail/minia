// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FEATURES_MINIA_H_
#define FLATBUFFERS_GENERATED_FEATURES_MINIA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
                  FLATBUFFERS_VERSION_MINOR == 2 &&
                  FLATBUFFERS_VERSION_REVISION == 10,
              "Non-compatible flatbuffers version included");

namespace minia {

struct FlatFloatArray;
struct FlatFloatArrayBuilder;

struct FlatFloatValue;
struct FlatFloatValueBuilder;

struct FlatInt64Array;
struct FlatInt64ArrayBuilder;

struct FlatInt64Value;
struct FlatInt64ValueBuilder;

struct FlatStringArray;
struct FlatStringArrayBuilder;

struct FlatStringValue;
struct FlatStringValueBuilder;

struct FlatNil;
struct FlatNilBuilder;

struct FlatValueWrapper;
struct FlatValueWrapperBuilder;

struct FlatFeatures;
struct FlatFeaturesBuilder;

enum FlatValue : uint8_t {
  FlatValue_NONE = 0,
  FlatValue_FlatInt64Value = 1,
  FlatValue_FlatFloatValue = 2,
  FlatValue_FlatStringValue = 3,
  FlatValue_FlatInt64Array = 4,
  FlatValue_FlatFloatArray = 5,
  FlatValue_FlatStringArray = 6,
  FlatValue_FlatNil = 7,
  FlatValue_MIN = FlatValue_NONE,
  FlatValue_MAX = FlatValue_FlatNil
};

inline const FlatValue (&EnumValuesFlatValue())[8] {
  static const FlatValue values[] = {FlatValue_NONE,
                                     FlatValue_FlatInt64Value,
                                     FlatValue_FlatFloatValue,
                                     FlatValue_FlatStringValue,
                                     FlatValue_FlatInt64Array,
                                     FlatValue_FlatFloatArray,
                                     FlatValue_FlatStringArray,
                                     FlatValue_FlatNil};
  return values;
}

inline const char *const *EnumNamesFlatValue() {
  static const char *const names[9] = {
      "NONE",           "FlatInt64Value", "FlatFloatValue",  "FlatStringValue",
      "FlatInt64Array", "FlatFloatArray", "FlatStringArray", "FlatNil",
      nullptr};
  return names;
}

inline const char *EnumNameFlatValue(FlatValue e) {
  if (::flatbuffers::IsOutRange(e, FlatValue_NONE, FlatValue_FlatNil))
    return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFlatValue()[index];
}

template <typename T> struct FlatValueTraits {
  static const FlatValue enum_value = FlatValue_NONE;
};

template <> struct FlatValueTraits<minia::FlatInt64Value> {
  static const FlatValue enum_value = FlatValue_FlatInt64Value;
};

template <> struct FlatValueTraits<minia::FlatFloatValue> {
  static const FlatValue enum_value = FlatValue_FlatFloatValue;
};

template <> struct FlatValueTraits<minia::FlatStringValue> {
  static const FlatValue enum_value = FlatValue_FlatStringValue;
};

template <> struct FlatValueTraits<minia::FlatInt64Array> {
  static const FlatValue enum_value = FlatValue_FlatInt64Array;
};

template <> struct FlatValueTraits<minia::FlatFloatArray> {
  static const FlatValue enum_value = FlatValue_FlatFloatArray;
};

template <> struct FlatValueTraits<minia::FlatStringArray> {
  static const FlatValue enum_value = FlatValue_FlatStringArray;
};

template <> struct FlatValueTraits<minia::FlatNil> {
  static const FlatValue enum_value = FlatValue_FlatNil;
};

bool VerifyFlatValue(::flatbuffers::Verifier &verifier, const void *obj,
                     FlatValue type);
bool VerifyFlatValueVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types);

struct FlatFloatArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatFloatArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<float> *value() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) && verifier.EndTable();
  }
};

struct FlatFloatArrayBuilder {
  typedef FlatFloatArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(FlatFloatArray::VT_VALUE, value);
  }
  explicit FlatFloatArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatFloatArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatFloatArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatFloatArray> CreateFlatFloatArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> value = 0) {
  FlatFloatArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatFloatArray>
CreateFlatFloatArrayDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                           const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return minia::CreateFlatFloatArray(_fbb, value__);
}

struct FlatFloatValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatFloatValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) && verifier.EndTable();
  }
};

struct FlatFloatValueBuilder {
  typedef FlatFloatValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(FlatFloatValue::VT_VALUE, value, 0.0f);
  }
  explicit FlatFloatValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatFloatValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatFloatValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatFloatValue>
CreateFlatFloatValue(::flatbuffers::FlatBufferBuilder &_fbb,
                     float value = 0.0f) {
  FlatFloatValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct FlatInt64Array FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatInt64ArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<int64_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) && verifier.EndTable();
  }
};

struct FlatInt64ArrayBuilder {
  typedef FlatInt64Array Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> value) {
    fbb_.AddOffset(FlatInt64Array::VT_VALUE, value);
  }
  explicit FlatInt64ArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatInt64Array> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatInt64Array>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatInt64Array> CreateFlatInt64Array(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> value = 0) {
  FlatInt64ArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatInt64Array>
CreateFlatInt64ArrayDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                           const std::vector<int64_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int64_t>(*value) : 0;
  return minia::CreateFlatInt64Array(_fbb, value__);
}

struct FlatInt64Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatInt64ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) && verifier.EndTable();
  }
};

struct FlatInt64ValueBuilder {
  typedef FlatInt64Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(FlatInt64Value::VT_VALUE, value, 0);
  }
  explicit FlatInt64ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatInt64Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatInt64Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatInt64Value>
CreateFlatInt64Value(::flatbuffers::FlatBufferBuilder &_fbb,
                     int64_t value = 0) {
  FlatInt64ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct FlatStringArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatStringArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  value() const {
    return GetPointer<const ::flatbuffers::Vector<
        ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.VerifyVectorOfStrings(value()) && verifier.EndTable();
  }
};

struct FlatStringArrayBuilder {
  typedef FlatStringArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void
  add_value(::flatbuffers::Offset<
            ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
                value) {
    fbb_.AddOffset(FlatStringArray::VT_VALUE, value);
  }
  explicit FlatStringArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatStringArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatStringArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatStringArray> CreateFlatStringArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
        value = 0) {
  FlatStringArrayBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatStringArray> CreateFlatStringArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *value =
        nullptr) {
  auto value__ =
      value ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
                  *value)
            : 0;
  return minia::CreateFlatStringArray(_fbb, value__);
}

struct FlatStringValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatStringValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) && verifier.EndTable();
  }
};

struct FlatStringValueBuilder {
  typedef FlatStringValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(FlatStringValue::VT_VALUE, value);
  }
  explicit FlatStringValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatStringValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatStringValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatStringValue>
CreateFlatStringValue(::flatbuffers::FlatBufferBuilder &_fbb,
                      ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  FlatStringValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatStringValue>
CreateFlatStringValueDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                            const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return minia::CreateFlatStringValue(_fbb, value__);
}

struct FlatNil FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatNilBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && verifier.EndTable();
  }
};

struct FlatNilBuilder {
  typedef FlatNil Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FlatNilBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatNil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatNil>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatNil>
CreateFlatNil(::flatbuffers::FlatBufferBuilder &_fbb) {
  FlatNilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FlatValueWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatValueWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  minia::FlatValue value_type() const {
    return static_cast<minia::FlatValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const { return GetPointer<const void *>(VT_VALUE); }
  template <typename T> const T *value_as() const;
  const minia::FlatInt64Value *value_as_FlatInt64Value() const {
    return value_type() == minia::FlatValue_FlatInt64Value
               ? static_cast<const minia::FlatInt64Value *>(value())
               : nullptr;
  }
  const minia::FlatFloatValue *value_as_FlatFloatValue() const {
    return value_type() == minia::FlatValue_FlatFloatValue
               ? static_cast<const minia::FlatFloatValue *>(value())
               : nullptr;
  }
  const minia::FlatStringValue *value_as_FlatStringValue() const {
    return value_type() == minia::FlatValue_FlatStringValue
               ? static_cast<const minia::FlatStringValue *>(value())
               : nullptr;
  }
  const minia::FlatInt64Array *value_as_FlatInt64Array() const {
    return value_type() == minia::FlatValue_FlatInt64Array
               ? static_cast<const minia::FlatInt64Array *>(value())
               : nullptr;
  }
  const minia::FlatFloatArray *value_as_FlatFloatArray() const {
    return value_type() == minia::FlatValue_FlatFloatArray
               ? static_cast<const minia::FlatFloatArray *>(value())
               : nullptr;
  }
  const minia::FlatStringArray *value_as_FlatStringArray() const {
    return value_type() == minia::FlatValue_FlatStringArray
               ? static_cast<const minia::FlatStringArray *>(value())
               : nullptr;
  }
  const minia::FlatNil *value_as_FlatNil() const {
    return value_type() == minia::FlatValue_FlatNil
               ? static_cast<const minia::FlatNil *>(value())
               : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyFlatValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template <>
inline const minia::FlatInt64Value *
FlatValueWrapper::value_as<minia::FlatInt64Value>() const {
  return value_as_FlatInt64Value();
}

template <>
inline const minia::FlatFloatValue *
FlatValueWrapper::value_as<minia::FlatFloatValue>() const {
  return value_as_FlatFloatValue();
}

template <>
inline const minia::FlatStringValue *
FlatValueWrapper::value_as<minia::FlatStringValue>() const {
  return value_as_FlatStringValue();
}

template <>
inline const minia::FlatInt64Array *
FlatValueWrapper::value_as<minia::FlatInt64Array>() const {
  return value_as_FlatInt64Array();
}

template <>
inline const minia::FlatFloatArray *
FlatValueWrapper::value_as<minia::FlatFloatArray>() const {
  return value_as_FlatFloatArray();
}

template <>
inline const minia::FlatStringArray *
FlatValueWrapper::value_as<minia::FlatStringArray>() const {
  return value_as_FlatStringArray();
}

template <>
inline const minia::FlatNil *
FlatValueWrapper::value_as<minia::FlatNil>() const {
  return value_as_FlatNil();
}

struct FlatValueWrapperBuilder {
  typedef FlatValueWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(minia::FlatValue value_type) {
    fbb_.AddElement<uint8_t>(FlatValueWrapper::VT_VALUE_TYPE,
                             static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(FlatValueWrapper::VT_VALUE, value);
  }
  explicit FlatValueWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatValueWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatValueWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatValueWrapper>
CreateFlatValueWrapper(::flatbuffers::FlatBufferBuilder &_fbb,
                       minia::FlatValue value_type = minia::FlatValue_NONE,
                       ::flatbuffers::Offset<void> value = 0) {
  FlatValueWrapperBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct FlatFeatures FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlatFeaturesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *
  keys() const {
    return GetPointer<const ::flatbuffers::Vector<
        ::flatbuffers::Offset<::flatbuffers::String>> *>(VT_KEYS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<minia::FlatValueWrapper>> *
  values() const {
    return GetPointer<const ::flatbuffers::Vector<
        ::flatbuffers::Offset<minia::FlatValueWrapper>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           verifier.VerifyVectorOfStrings(keys()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) && verifier.EndTable();
  }
};

struct FlatFeaturesBuilder {
  typedef FlatFeatures Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void
  add_keys(::flatbuffers::Offset<
           ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
               keys) {
    fbb_.AddOffset(FlatFeatures::VT_KEYS, keys);
  }
  void add_values(
      ::flatbuffers::Offset<
          ::flatbuffers::Vector<::flatbuffers::Offset<minia::FlatValueWrapper>>>
          values) {
    fbb_.AddOffset(FlatFeatures::VT_VALUES, values);
  }
  explicit FlatFeaturesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
      : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FlatFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FlatFeatures>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FlatFeatures> CreateFlatFeatures(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>>
        keys = 0,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<minia::FlatValueWrapper>>>
        values = 0) {
  FlatFeaturesBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_keys(keys);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FlatFeatures> CreateFlatFeaturesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *keys =
        nullptr,
    const std::vector<::flatbuffers::Offset<minia::FlatValueWrapper>> *values =
        nullptr) {
  auto keys__ =
      keys ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(
                 *keys)
           : 0;
  auto values__ =
      values
          ? _fbb.CreateVector<::flatbuffers::Offset<minia::FlatValueWrapper>>(
                *values)
          : 0;
  return minia::CreateFlatFeatures(_fbb, keys__, values__);
}

inline bool VerifyFlatValue(::flatbuffers::Verifier &verifier, const void *obj,
                            FlatValue type) {
  switch (type) {
  case FlatValue_NONE: {
    return true;
  }
  case FlatValue_FlatInt64Value: {
    auto ptr = reinterpret_cast<const minia::FlatInt64Value *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case FlatValue_FlatFloatValue: {
    auto ptr = reinterpret_cast<const minia::FlatFloatValue *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case FlatValue_FlatStringValue: {
    auto ptr = reinterpret_cast<const minia::FlatStringValue *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case FlatValue_FlatInt64Array: {
    auto ptr = reinterpret_cast<const minia::FlatInt64Array *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case FlatValue_FlatFloatArray: {
    auto ptr = reinterpret_cast<const minia::FlatFloatArray *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case FlatValue_FlatStringArray: {
    auto ptr = reinterpret_cast<const minia::FlatStringArray *>(obj);
    return verifier.VerifyTable(ptr);
  }
  case FlatValue_FlatNil: {
    auto ptr = reinterpret_cast<const minia::FlatNil *>(obj);
    return verifier.VerifyTable(ptr);
  }
  default:
    return true;
  }
}

inline bool VerifyFlatValueVector(
    ::flatbuffers::Verifier &verifier,
    const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values,
    const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types)
    return !values && !types;
  if (values->size() != types->size())
    return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFlatValue(verifier, values->Get(i),
                         types->GetEnum<FlatValue>(i))) {
      return false;
    }
  }
  return true;
}

} // namespace minia

#endif // FLATBUFFERS_GENERATED_FEATURES_MINIA_H_
